package rankingServiceRdbZsetX

import (
	"context"
	"fmt"
	"gitee.com/hgg_test/pkg_tool/v2/DBx/cachex/cacheLocalx"
	"gitee.com/hgg_test/pkg_tool/v2/logx"
	"gitee.com/hgg_test/pkg_tool/v2/serviceLogicX/rankingListX/rankingServiceRdbZsetX/types"
	"github.com/redis/go-redis/v9"
	"sort"
	"sync"
	"time"
)

// RankingServiceZset 实时排行榜服务
type RankingServiceZset struct {
	shardCount int                                                // 分片数，如 16，默认10
	keyPrefix  string                                             // Redis key 前缀，如 "hot_articles"，默认"hot_"
	redisCache redis.Cmdable                                      // Redis 客户端（或 Cluster）
	localCache cacheLocalx.CacheLocalIn[string, []types.HotScore] // 本地缓存
	provider   types.ScoreProvider                                // 分数提供器
	logger     logx.Loggerx

	// 用于控制后台 goroutine 生命周期
	ctx    context.Context
	cancel context.CancelFunc
	once   sync.Once
}

func NewRankingService(
	redisCache redis.Cmdable,
	localCache cacheLocalx.CacheLocalIn[string, []types.HotScore],
	provider types.ScoreProvider,
	logger logx.Loggerx,
) *RankingServiceZset {
	return &RankingServiceZset{
		shardCount: 10,
		keyPrefix:  "hot_",
		redisCache: redisCache,
		localCache: localCache,
		provider:   provider,
		logger:     logger,
	}
}

// Start 启动后台缓存刷新（建议显式调用）
func (s *RankingServiceZset) Start(refreshInterval time.Duration) {
	s.once.Do(func() {
		go s.backgroundRefresh(s.ctx, refreshInterval)
	})
}

// Stop 停止后台任务
func (s *RankingServiceZset) Stop() {
	s.cancel()
}

// backgroundRefresh 后台定时刷新缓存
func (s *RankingServiceZset) backgroundRefresh(ctx context.Context, interval time.Duration) {
	ticker := time.NewTicker(interval)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			s.logger.Info("background refresh stopped")
			return
		case <-ticker.C:
			_ = s.refreshCache(ctx, 100) // 预加载 Top 100
		}
	}
}

// 缓存的统一 key（按业务维度，如 "hot_article_top100"）
func (s *RankingServiceZset) cacheKey() string {
	// 如果未来支持多榜单，可传入 bizType，目前用固定 key
	return s.keyPrefix + "top100"
}

// refreshCache 从 Redis 拉取 TopN 并写入本地缓存
func (s *RankingServiceZset) refreshCache(ctx context.Context, topN int) error {
	items, err := s.fetchTopNFromRedis(ctx, topN)
	if err != nil {
		s.logger.Warn("failed to refresh local cache", logx.Error(err))
		return err
	}
	s.logger.Debug("refreshed local cache, 本地缓存刷新榜单", logx.Int("len(items)", len(items)))

	// 写入本地缓存：5秒TTL，版本号可忽略（传1）
	return s.localCache.Set(s.cacheKey(), items, 5*time.Second, 1)
}

// GetTopN 获取 TopN 榜单（优先本地缓存）
func (s *RankingServiceZset) GetTopN(ctx context.Context, topN int) ([]types.HotScore, error) {
	// 1. 尝试本地缓存
	if items, ok := s.localCache.Get(s.cacheKey()); ok == nil && len(items) >= topN {
		return items[:topN], nil
	}

	// 2. 缓存未命中或不足，回源 Redis
	items, err := s.fetchTopNFromRedis(ctx, topN)
	if err != nil {
		return nil, err
	}

	// 可选：异步写回缓存（或由后台任务统一刷新）
	return items, nil
}

// fetchTopNFromRedis 从所有分片 ZSET 中归并 TopN
func (s *RankingServiceZset) fetchTopNFromRedis(ctx context.Context, topN int) ([]types.HotScore, error) {
	type result struct {
		items []types.HotScore
		err   error
	}
	ch := make(chan result, s.shardCount)

	for i := 0; i < s.shardCount; i++ {
		go func(shard int) {
			key := s.buildZSetKey(shard)
			zs, err := s.redisCache.ZRevRangeWithScores(ctx, key, 0, int64(topN-1)).Result()
			if err != nil {
				ch <- result{err: err}
				return
			}

			var items []types.HotScore
			for _, z := range zs {
				member, ok := z.Member.(string)
				if !ok {
					continue
				}
				score := z.Score // float64
				// 注意：这里缺失 Biz 和 Title！见下方【重要说明】
				items = append(items, types.HotScore{
					Biz:   "",     // ⚠️ 无法从 ZSET 获取
					BizID: member, // 假设 member = "article_123"
					Score: score,
					Title: "", // ⚠️ 无法从 ZSET 获取
				})
			}
			ch <- result{items: items}
		}(i)
	}

	// 收集所有分片结果
	var allItems []types.HotScore
	for i := 0; i < s.shardCount; i++ {
		r := <-ch
		if r.err != nil {
			return nil, r.err
		}
		allItems = append(allItems, r.items...)
	}

	// 全局排序
	sort.Slice(allItems, func(i, j int) bool {
		return s.provider.Score(allItems[i]) > s.provider.Score(allItems[j])
	})

	if len(allItems) > topN {
		allItems = allItems[:topN]
	}
	return allItems, nil
}

// IncrScore 更新某个 BizID 的分数
func (s *RankingServiceZset) IncrScore(ctx context.Context, bizID string, delta float64) error {
	shard := s.getShard(bizID)
	key := s.buildZSetKey(shard)
	_, err := s.redisCache.ZIncrBy(ctx, key, delta, bizID).Result()
	if err != nil {
		s.logger.Error("failed to incr score in redis",
			logx.String("biz_id", bizID),
			logx.Float64("delta", delta),
			logx.Error(err))
	}
	return err
}

// buildZSetKey 构建 Redis ZSET key
func (s *RankingServiceZset) buildZSetKey(shard int) string {
	return fmt.Sprintf("%s%d", s.keyPrefix, shard)
}

// getShard 根据 BizID 哈希分片
func (s *RankingServiceZset) getShard(bizID string) int {
	hash := fnv1a32(bizID)
	return int(hash % uint32(s.shardCount))
}

// FNV-1a 32位哈希
func fnv1a32(data string) uint32 {
	const (
		offset32 = 2166136261
		prime32  = 16777619
	)
	hash := uint32(offset32)
	for _, c := range data {
		hash ^= uint32(c)
		hash *= prime32
	}
	return hash
}
