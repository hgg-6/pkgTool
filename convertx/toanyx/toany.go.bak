package toanyx

import (
	"encoding/json"
	"fmt"
	"strconv"
	"strings"
	"time"
)

// dstTypeValue 泛型约束，返回值支持的类型
type dstTypeValue interface {
	// 基础类型
	~int | ~int8 | ~int16 | ~int32 | ~int64 |
		~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 |
		~float32 | ~float64 |
		~string | ~bool |
		// 时间类型
		time.Time |
		//time.Duration |
		// 切片类型
		~[]string | ~[]int | ~[]int64 | ~[]float64 |
		// map 类型
		~map[string]string | ~map[string]any
}

// ToAny 通用类型转换，兼容大部分类型转换，返回零值转换失败【调用者需判断零值】
/*
	- var a int： int 类型的零值是 0。

	- var b string： string 的零值是 ""（空字符串）。

	- var c bool： bool 的零值是 false。

	- var d struct{...}： 结构体的零值是其中所有字段各自为其零值的状态。

	- var e [5]int： 数组的零值是所有元素为其零值的状态（例如 [0, 0, 0, 0, 0]）。
	- .................
*/
func ToAny[EvenT dstTypeValue](v any) EvenT {
	return convertToType[EvenT](v)
}

// convertToType 核心转换逻辑
func convertToType[EvenT dstTypeValue](src any) EvenT {
	var zero EvenT

	if src == nil {
		return zero
	}

	// 尝试直接类型断言
	if v, ok := src.(EvenT); ok {
		return v
	}

	// 类型不匹配，尝试常见兼容转换
	switch any(zero).(type) {

	// ========== 整数类型 ==========
	case int:
		switch val := src.(type) {
		case float64:
			return any(int(val)).(EvenT)
		case int64:
			return any(int(val)).(EvenT)
		case string:
			if i, err := strconv.Atoi(val); err == nil {
				return any(i).(EvenT)
			}
		}
	case int8:
		switch val := src.(type) {
		case float64:
			return any(int8(val)).(EvenT)
		case int64:
			return any(int8(val)).(EvenT)
		case int:
			return any(int8(val)).(EvenT)
		case string:
			if i, err := strconv.ParseInt(val, 10, 8); err == nil {
				return any(int8(i)).(EvenT)
			}
		}
	case int16:
		switch val := src.(type) {
		case float64:
			return any(int16(val)).(EvenT)
		case int64:
			return any(int16(val)).(EvenT)
		case int:
			return any(int16(val)).(EvenT)
		case string:
			if i, err := strconv.ParseInt(val, 10, 16); err == nil {
				return any(int16(i)).(EvenT)
			}
		}
	case int32:
		switch val := src.(type) {
		case float64:
			return any(int32(val)).(EvenT)
		case int64:
			return any(int32(val)).(EvenT)
		case int:
			return any(int32(val)).(EvenT)
		case string:
			if i, err := strconv.ParseInt(val, 10, 32); err == nil {
				return any(int32(i)).(EvenT)
			}
		}
	case int64:
		switch val := src.(type) {
		case int:
			return any(int64(val)).(EvenT)
		case float64:
			return any(int64(val)).(EvenT)
		case string:
			if i, err := strconv.ParseInt(val, 10, 64); err == nil {
				return any(i).(EvenT)
			}
		}

	// ========== 无符号整数类型 ==========
	case uint:
		switch val := src.(type) {
		case float64:
			return any(uint(val)).(EvenT)
		case int64:
			if val >= 0 {
				return any(uint(val)).(EvenT)
			}
		case string:
			if u, err := strconv.ParseUint(val, 10, 64); err == nil {
				return any(uint(u)).(EvenT)
			}
		}
	case uint8:
		switch val := src.(type) {
		case float64:
			return any(uint8(val)).(EvenT)
		case int64:
			if val >= 0 && val <= 255 {
				return any(uint8(val)).(EvenT)
			}
		case uint:
			return any(uint8(val)).(EvenT)
		case string:
			if u, err := strconv.ParseUint(val, 10, 8); err == nil {
				return any(uint8(u)).(EvenT)
			}
		}
	case uint16:
		switch val := src.(type) {
		case float64:
			return any(uint16(val)).(EvenT)
		case int64:
			if val >= 0 && val <= 65535 {
				return any(uint16(val)).(EvenT)
			}
		case uint:
			return any(uint16(val)).(EvenT)
		case string:
			if u, err := strconv.ParseUint(val, 10, 16); err == nil {
				return any(uint16(u)).(EvenT)
			}
		}
	case uint32:
		switch val := src.(type) {
		case float64:
			return any(uint32(val)).(EvenT)
		case int64:
			if val >= 0 && val <= 0xFFFFFFFF {
				return any(uint32(val)).(EvenT)
			}
		case uint:
			return any(uint32(val)).(EvenT)
		case string:
			if u, err := strconv.ParseUint(val, 10, 32); err == nil {
				return any(uint32(u)).(EvenT)
			}
		}
	case uint64:
		switch val := src.(type) {
		case int64:
			if val >= 0 {
				return any(uint64(val)).(EvenT)
			}
		case float64:
			if val >= 0 {
				return any(uint64(val)).(EvenT)
			}
		case uint:
			return any(uint64(val)).(EvenT)
		case string:
			if u, err := strconv.ParseUint(val, 10, 64); err == nil {
				return any(u).(EvenT)
			}
		}

	// ========== 浮点数类型 ==========
	case float32:
		switch val := src.(type) {
		case int, int64:
			return any(float32(val.(int64))).(EvenT)
		case float64:
			return any(float32(val)).(EvenT)
		case string:
			if f, err := strconv.ParseFloat(val, 32); err == nil {
				return any(float32(f)).(EvenT)
			}
		}
	case float64:
		switch val := src.(type) {
		case int, int64:
			return any(float64(val.(int64))).(EvenT)
		case float32:
			return any(float64(val)).(EvenT)
		case string:
			if f, err := strconv.ParseFloat(val, 64); err == nil {
				return any(f).(EvenT)
			}
		}

	// ========== 字符串、布尔 ==========
	case string:
		return any(fmt.Sprintf("%v", src)).(EvenT)
	case bool:
		switch val := src.(type) {
		case string:
			switch strings.ToLower(val) {
			case "true", "1", "on", "yes":
				return any(true).(EvenT)
			case "false", "0", "off", "no":
				return any(false).(EvenT)
			}
		case int, int64:
			return any(val != 0).(EvenT)
		case float64:
			return any(val != 0).(EvenT)
		case uint, uint64:
			return any(val != 0).(EvenT)
		}

	// ========== 切片类型 ==========
	case []string:
		var result []string
		switch val := src.(type) {
		case []string:
			result = val
		case []any:
			result = make([]string, len(val))
			for i, item := range val {
				result[i] = fmt.Sprintf("%v", item)
			}
		case string:
			if len(val) > 0 {
				parts := strings.Split(val, ",")
				result = make([]string, len(parts))
				for i, p := range parts {
					result[i] = strings.TrimSpace(p)
				}
			} else {
				result = []string{}
			}
		default:
			if bs, err := json.Marshal(src); err == nil {
				var arr []string
				if json.Unmarshal(bs, &arr) == nil {
					result = arr
				}
			}
		}
		if result != nil {
			return any(result).(EvenT)
		}

	case []int:
		var result []int
		switch val := src.(type) {
		case []any:
			result = make([]int, len(val))
			for i, item := range val {
				switch v := item.(type) {
				case float64:
					result[i] = int(v)
				case int64:
					result[i] = int(v)
				case string:
					if n, err := strconv.Atoi(v); err == nil {
						result[i] = n
					}
				}
			}
		case []int:
			result = val
		case string:
			if err := json.Unmarshal([]byte(val), &result); err != nil {
				result = []int{}
			}
		}
		return any(result).(EvenT)

	case []int64:
		var result []int64
		switch val := src.(type) {
		case []any:
			result = make([]int64, len(val))
			for i, item := range val {
				switch v := item.(type) {
				case float64:
					result[i] = int64(v)
				case int:
					result[i] = int64(v)
				case string:
					if n, err := strconv.ParseInt(v, 10, 64); err == nil {
						result[i] = n
					}
				}
			}
		case []int64:
			result = val
		case string:
			if err := json.Unmarshal([]byte(val), &result); err != nil {
				result = []int64{}
			}
		}
		return any(result).(EvenT)

	case []float64:
		var result []float64
		switch val := src.(type) {
		case []any:
			result = make([]float64, len(val))
			for i, item := range val {
				switch v := item.(type) {
				case int, int64:
					result[i] = float64(v.(int64))
				case float32:
					result[i] = float64(v)
				case string:
					if f, err := strconv.ParseFloat(v, 64); err == nil {
						result[i] = f
					}
				}
			}
		case []float64:
			result = val
		case string:
			if err := json.Unmarshal([]byte(val), &result); err != nil {
				result = []float64{}
			}
		}
		return any(result).(EvenT)

	// ========== 时间、Map 类型 ==========
	case time.Time:
		switch val := src.(type) {
		case string:
			for _, layout := range []string{
				time.RFC3339,
				"2006-01-02 15:04:05",
				"2006-01-02",
				time.ANSIC,
				time.UnixDate,
				time.RFC822,
				time.RFC1123,
			} {
				if t, err := time.Parse(layout, val); err == nil {
					return any(t).(EvenT)
				}
			}
		case int:
			return any(time.Unix(int64(val), 0)).(EvenT)
		case int8:
			return any(time.Unix(int64(val), 0)).(EvenT)
		case int16:
			return any(time.Unix(int64(val), 0)).(EvenT)
		case int32:
			return any(time.Unix(int64(val), 0)).(EvenT)
		case int64:
			return any(time.Unix(val, 0)).(EvenT)
		case float32:
			return any(time.Unix(int64(val), 0)).(EvenT)
		case float64:
			return any(time.Unix(int64(val), 0)).(EvenT)
		case uint:
			return any(time.Unix(int64(val), 0)).(EvenT)
		case uint8:
			return any(time.Unix(int64(val), 0)).(EvenT)
		case uint16:
			return any(time.Unix(int64(val), 0)).(EvenT)
		case uint32:
			return any(time.Unix(int64(val), 0)).(EvenT)
		case uint64:
			return any(time.Unix(int64(val), 0)).(EvenT)
		}
	case time.Duration:
		switch val := src.(type) {
		case string:
			if d, err := time.ParseDuration(val); err == nil {
				return any(d).(EvenT)
			}
		case int:
			return any(time.Duration(val)).(EvenT)
		case int8:
			return any(time.Duration(val)).(EvenT)
		case int16:
			return any(time.Duration(val)).(EvenT)
		case int32:
			return any(time.Duration(val)).(EvenT)
		case int64:
			return any(time.Duration(val)).(EvenT)
		case float32:
			return any(time.Duration(val)).(EvenT)
		case float64:
			return any(time.Duration(val)).(EvenT)
		case uint:
			return any(time.Duration(val)).(EvenT)
		case uint8:
			return any(time.Duration(val)).(EvenT)
		case uint16:
			return any(time.Duration(val)).(EvenT)
		case uint32:
			return any(time.Duration(val)).(EvenT)
		case uint64:
			return any(time.Duration(val)).(EvenT)
		}

	// ========== 映射类型 ==========
	case map[string]string:
		result := make(map[string]string)
		switch val := src.(type) {
		case map[string]any:
			for k, v := range val {
				result[k] = fmt.Sprintf("%v", v)
			}
			return any(result).(EvenT)
		case map[string]string:
			return any(val).(EvenT)
		}

	case map[string]any:
		if m, ok := src.(map[string]any); ok {
			return any(m).(EvenT)
		}
	}

	// 转换失败，返回零值（或 panic）
	// panic(fmt.Sprintf("config Key '%s': cannot convert %EvenT to %EvenT", Key, src, zero))
	return zero
}
