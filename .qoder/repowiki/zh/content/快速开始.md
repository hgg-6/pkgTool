# 快速开始

<cite>
**本文档中引用的文件**
- [README.md](file://README.md)
- [go.mod](file://go.mod)
- [double_write_pool.go](file://DBx/mysqlX/gormx/dbMovex/myMovex/doubleWritePoolx/double_write_pool.go)
- [count.go](file://DBx/redisX/cacheCountServiceX/count.go)
- [producer.go](file://channelx/mqX/kafkaX/saramaX/producerX/producer.go)
- [consumer.go](file://channelx/mqX/kafkaX/saramaX/consumerX/consumer.go)
- [viper.go](file://configx/viperX/viper.go)
- [toany.go](file://convertx/toanyx/toany.go)
- [redis_slide_window.go](file://limiter/redis_slide_window.go)
- [redsync.go](file://syncX/lock/redisLock/redsyncx/redsync.go)
- [zapLogger.go](file://logx/zaplogx/zapLogger.go)
- [jwtx.go](file://webx/ginx/middleware/jwtx/jwtx.go)
- [jwt.go](file://webx/ginx/middleware/jwtX2/jwt.go)
- [db.yaml](file://configx/viperX/db.yaml)
- [redis.yaml](file://configx/viperX/redis.yaml)
- [slide_window.lua](file://limiter/slide_window.lua)
- [cnt.lua](file://DBx/redisX/cacheCountServiceX/lua/cnt.lua)
</cite>

## 目录
1. [环境要求与安装](#环境要求与安装)
2. [核心功能使用指南](#核心功能使用指南)
   1. [创建缓存计数服务](#创建缓存计数服务)
   2. [配置数据库双写池](#配置数据库双写池)
   3. [初始化Kafka生产者](#初始化kafka生产者)
   4. [初始化Kafka消费者](#初始化kafka消费者)
   5. [加载Viper配置](#加载viper配置)
   6. [进行类型转换](#进行类型转换)
   7. [设置Redis滑动窗口限流器](#设置redis滑动窗口限流器)
   8. [创建Redsync分布式锁](#创建redsync分布式锁)
   9. [配置Zap日志记录器](#配置zap日志记录器)
   10. [在Gin框架中集成JWT认证中间件](#在gin框架中集成jwt认证中间件)
3. [总结](#总结)

## 环境要求与安装

要使用 `pkg_tool` 模块，您需要确保开发环境满足以下要求：

- **Go版本**：必须使用 Go 1.24.3 或更高版本。您可以通过运行 `go version` 命令来检查当前安装的 Go 版本。
- **网络连接**：需要能够访问 Gitee 代码托管平台以下载模块。

安装 `pkg_tool` 模块非常简单，只需在您的项目目录中执行以下命令：

```bash
go get gitee.com/hgg_test/pkg_tool/v2@latest
```

此命令将从 Gitee 获取 `pkg_tool/v2` 模块的最新版本，并将其添加到您的 `go.mod` 文件中。安装完成后，您就可以在项目中导入并使用该工具包提供的各种功能。

**Section sources**
- [README.md](file://README.md#L19-L25)
- [go.mod](file://go.mod#L3)

## 核心功能使用指南

本节将详细介绍如何使用 `pkg_tool` 中的核心功能。每个示例都基于 `README.md` 中的说明，并结合实际代码实现进行分步演示。

### 创建缓存计数服务

`pkg_tool` 提供了基于 Redis 和本地缓存的计数服务，可以高效地处理计数和榜单计算。该服务优先命中本地缓存，以减少对 Redis 的访问压力。

首先，您需要创建一个 Redis 客户端和一个本地缓存实例。然后，使用 `cacheCountServiceX.NewCount` 函数来创建计数服务。

```go
redisClient := redis.NewClient(&redis.Options{
    Addr: "localhost:6379",
})

localCache := cacheLocalx.NewCacheLocalRistrettoStr[string, string](ristretto.NewCache[string, string]())

countService := cacheCountServicex.NewCount[string, string](redisClient, localCache)
```

创建的 `countService` 实例可以用于执行计数操作和维护榜单数据。它通过 Lua 脚本与 Redis 交互，确保操作的原子性。

**Section sources**
- [README.md](file://README.md#L29-L39)
- [count.go](file://DBx/redisX/cacheCountServiceX/count.go#L72-L96)
- [cnt.lua](file://DBx/redisX/cacheCountServiceX/lua/cnt.lua)

### 配置数据库双写池

数据库双写池功能允许您在迁移数据库时，同时向源数据库和目标数据库写入数据，确保数据的一致性。

要配置双写池，您需要提供源数据库和目标数据库的连接实例，以及一个日志记录器。`dbMovex.NewDoubleWritePool` 函数将返回一个 `DoubleWritePool` 实例。

```go
srcDB, _ := gorm.Open(mysql.Open("user:pass@tcp(localhost:3306)/src_db"), &gorm.Config{})
dstDB, _ := gorm.Open(mysql.Open("user:pass@tcp(localhost:3306)/dst_db"), &gorm.Config{})

doubleWritePool := dbMovex.NewDoubleWritePool(srcDB, dstDB, logger, config...)
```

`DoubleWritePool` 支持多种双写模式，如 `src_only`、`src_first`、`dst_first` 和 `dst_only`。您可以通过 `UpdatePattern` 方法动态切换模式。

**Section sources**
- [README.md](file://README.md#L41-L48)
- [double_write_pool.go](file://DBx/mysqlX/gormx/dbMovex/myMovex/doubleWritePoolx/double_write_pool.go#L59-L87)

### 初始化Kafka生产者

`pkg_tool` 提供了对 Kafka 生产者的封装，支持同步和异步模式。

要初始化一个 Kafka 生产者，您需要提供 Kafka 服务器的地址和生产者配置。`NewKafkaProducer` 函数将返回一个 `mqX.Producer` 接口实例。

```go
config := sarama.NewConfig()
config.Producer.Return.Successes = true

producer, _ := sarama.NewSyncProducer([]string{"localhost:9092"}, config)
messageProducer := saramaProducerx.NewSaramaProducerStr[sarama.SyncProducer](producer, config)
```

生产者支持批量发送和超时刷新机制，可以在异步模式下提高性能。

**Section sources**
- [README.md](file://README.md#L50-L57)
- [producer.go](file://channelx/mqX/kafkaX/saramaX/producerX/producer.go#L33-L69)

### 初始化Kafka消费者

Kafka 消费者同样被封装以提供更简洁的 API。

初始化消费者需要一个 `sarama.ConsumerGroup` 实例和消费者配置。`NewKafkaConsumer` 函数返回一个 `KafkaConsumer` 实例。

```go
consumerGroup, _ := sarama.NewConsumerGroup([]string{"localhost:9092"}, "group_id", sarama.NewConfig())
consumer := saramaConsumerx.NewConsumerIn(consumerGroup, handler)
```

消费者支持单条和批量处理模式，并可以通过 `IsBatch()` 方法判断处理方式。

**Section sources**
- [README.md](file://README.md#L60-L64)
- [consumer.go](file://channelx/mqX/kafkaX/saramaX/consumerX/consumer.go#L19-L30)

### 加载Viper配置

`pkg_tool` 使用 Viper 库来管理配置文件，支持本地和远程配置。

您可以使用 `viperx.NewViperConfigStr` 创建一个配置服务，并通过 `InitViperLocal` 方法加载本地配置文件。

```go
viperConfig := viper.New()
viperConfig.SetDefault("mysql.dsn", "user:pass@tcp(localhost:3306)/dbname")

configService := viperx.NewViperConfigStr()
configService.InitViperLocal("config.yaml", DefaultConfig{})
```

该功能还支持监听配置文件的变化，并在变化时触发回调函数。

**Section sources**
- [README.md](file://README.md#L67-L74)
- [viper.go](file://configx/viperX/viper.go#L26-L74)
- [db.yaml](file://configx/viperX/db.yaml)
- [redis.yaml](file://configx/viperX/redis.yaml)

### 进行类型转换

`pkg_tool` 提供了一个安全的类型转换工具 `toanyx.ToAny`，可以将任意类型转换为指定的目标类型。

```go
intValue, ok := toanyx.ToAny[int](someValue)
stringValue, ok := toanyx.ToAny[string](someValue)
```

该函数返回转换后的值和一个布尔值，表示转换是否成功。它支持多种基础类型、时间类型、切片和映射的转换。

**Section sources**
- [README.md](file://README.md#L77-L82)
- [toany.go](file://convertx/toanyx/toany.go#L29-L580)

### 设置Redis滑动窗口限流器

滑动窗口限流器是一种有效的流量控制机制，可以防止系统被突发流量压垮。

要创建一个限流器，您需要提供一个 Redis 命令接口、窗口大小和阈值。`redis_slide_window.NewRedisSlideWindowKLimiter` 函数将返回一个 `RedisSlideWindowKLimiter` 实例。

```go
redisClient := redis.NewClient(&redis.Options{
    Addr: "localhost:6379",
})

limiter := redis_slide_window.NewRedisSlideWindowKLimiter(redisClient, time.Minute, 100)
```

限流器使用 Lua 脚本在 Redis 中实现滑动窗口算法，确保限流逻辑的高效和准确。

**Section sources**
- [README.md](file://README.md#L86-L91)
- [redis_slide_window.go](file://limiter/redis_slide_window.go#L31-L41)
- [slide_window.lua](file://limiter/slide_window.lua)

### 创建Redsync分布式锁

分布式锁是分布式系统中协调资源访问的重要工具。`pkg_tool` 基于 `go-redsync` 库提供了 `redsyncx.LockRedsync`。

创建分布式锁需要提供 Redis 客户端列表、日志记录器和锁配置。

```go
redisClients := []*redis.Client{
    redis.NewClient(&redis.Options{Addr: "localhost:6379"}),
}

lock := redsyncx.NewLockRedsync(redisClients, logger, redsyncx.Config{})
```

该锁支持自动续约和状态监控，确保在持有锁期间不会因超时而丢失。

**Section sources**
- [README.md](file://README.md#L96-L101)
- [redsync.go](file://syncX/lock/redisLock/redsyncx/redsync.go#L96-L146)

### 配置Zap日志记录器

`pkg_tool` 支持使用 `go.uber.org/zap` 作为日志记录后端。

您可以通过 `zaplogx.NewZapLogger` 函数创建一个适配 `pkg_tool` 日志接口的 `ZapLogger` 实例。

```go
zapLogger, _ := zap.NewProduction()
logger := zaplogx.NewZapLogger(zapLogger)
```

创建的 `logger` 实例可以用于记录不同级别的日志信息。

**Section sources**
- [README.md](file://README.md#L106-L108)
- [zapLogger.go](file://logx/zaplogx/zapLogger.go#L17-L20)

### 在Gin框架中集成JWT认证中间件

`pkg_tool` 提供了与 Gin 框架集成的 JWT 认证中间件，用于保护 API 端点。

要集成 JWT 中间件，您需要创建一个 `jwtx.NewJwtxMiddlewareGinx` 实例，并将其作为中间件使用。

```go
r := gin.Default()

jwtMiddleware := jwtx.NewJwtxMiddlewareGinx(redisClient, &jwtx.JwtxMiddlewareGinxConfig{})
r.Use(jwtMiddleware.VerifyToken)
```

该中间件支持设置、验证、刷新和删除 JWT 令牌，并将用户信息存储在 Redis 中以增强安全性。

**Section sources**
- [README.md](file://README.md#L113-L117)
- [jwtx.go](file://webx/ginx/middleware/jwtx/jwtx.go#L33-L53)
- [jwt.go](file://webx/ginx/middleware/jwtX2/jwt.go#L39-L65)

## 总结

本文档详细介绍了如何在新项目中集成和使用 `pkg_tool` 工具包。我们从环境要求和安装开始，然后逐步演示了核心功能的初始化和使用方法，包括缓存计数服务、数据库双写池、Kafka 生产者和消费者、Viper 配置管理、类型转换、Redis 滑动窗口限流器、Redsync 分布式锁、Zap 日志记录器以及 Gin 框架中的 JWT 认证中间件。

通过遵循这些步骤，开发者可以快速上手并利用 `pkg_tool` 提供的强大功能来构建高效、可靠的 Go 应用程序。每个示例都包含了必要的代码片段和依赖说明，确保内容对新手友好且准确反映了代码库的实际 API。